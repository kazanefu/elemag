use super::super::*;
use bevy::prelude::*;

pub struct PointChargePlugin;

impl Plugin for PointChargePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, apply_electric_fields);
    }
}

pub trait ElectricMagneticField {
    fn field_at(&self, position: Vec3) -> Vec3;
}

// electric field generated by a point charge
#[derive(Component)]
pub struct PointField {
    pub q: f32,
    pub k: f32,
}

impl ElectricMagneticField for PointField {
    fn field_at(&self, position: Vec3) -> Vec3 {
        let r = position;
        let dist_sq = r.length_squared().max(1e-6); // not to be zero
        self.k * self.q * r.normalize() / dist_sq
    }
}

// uniform electric field
#[derive(Component)]
pub struct UniformElectricField {
    pub field: Vec3,
}

impl ElectricMagneticField for UniformElectricField {
    fn field_at(&self, _position: Vec3) -> Vec3 {
        self.field
    }
}

// magnetic field generated by a point charge
#[derive(Component)]
pub struct PointMagneticField {
    pub q: f32,
    pub k: f32,
}

impl ElectricMagneticField for PointMagneticField {
    fn field_at(&self, position: Vec3) -> Vec3 {
        let r = position;
        let dist_sq = r.length_squared().max(1e-6); // not to be zero
        self.k * self.q * r.normalize() / dist_sq
    }
}

// uniform magnetic field
#[derive(Component)]
pub struct UniformMagneticField {
    pub field: Vec3,
}

impl ElectricMagneticField for UniformMagneticField {
    fn field_at(&self, _position: Vec3) -> Vec3 {
        self.field
    }
}

// charge that interacts with electric field
#[derive(Component, Default)]
pub struct PointCharge {
    pub charge: f32,
    pub force: Vec3,
}

impl Force for PointCharge {
    fn apply(&self, physical_body: &mut PhysicalBody) {
        physical_body.add_force(self.get_force(physical_body));
    }
    fn get_force(&self, _physical_body: &PhysicalBody) -> Vec3 {
        self.force
    }
}

impl PointCharge {
    #[allow(dead_code)]
    pub fn new(charge: f32) -> Self {
        Self {
            charge,
            force: Vec3::ZERO,
        }
    }
}

pub fn apply_electric_fields(
    mut bodies: Query<(&mut PointCharge, &Transform, &PhysicalBody)>,
    point_fields: Query<(&PointField, &Transform)>,
    uniform_fields: Query<&UniformElectricField>,
    magnetic_fields: Query<(&PointMagneticField, &Transform)>,
    uniform_magnetic_fields: Query<&UniformMagneticField>,
) {
    for (mut charge, transform, body) in bodies.iter_mut() {
        charge.force = Vec3::ZERO;
        for (field, field_transform) in point_fields.iter() {
            let r = transform.translation - field_transform.translation;
            let field = field.field_at(r);
            charge.force = charge.force + field * charge.charge;
        }
        for field in uniform_fields.iter() {
            let field = field.field_at(Vec3::ZERO);
            charge.force = charge.force + field * charge.charge;
        }
        for (field, field_transform) in magnetic_fields.iter() {
            let r = transform.translation - field_transform.translation;
            let field = field.field_at(r);
            charge.force = charge.force + (field.cross(body.velocity)) * charge.charge;
        }
        for field in uniform_magnetic_fields.iter() {
            let field = field.field_at(Vec3::ZERO);
            charge.force = charge.force + (field.cross(body.velocity)) * charge.charge;
        }
    }
}
