{
  "Bevy Template": {
    "prefix": "bevy_template",
    "body": [
      "use bevy::{ecs::query, prelude::*};",
      "",
      "fn main() {",
      "    println!(\"hello world\");",
      "    App::new()",
      "        .add_plugins(DefaultPlugins)",
      "        .add_systems(Startup, startup)",
      "        .add_systems(Update, move_square)",
      "        .run();",
      "}",
      "",
      "#[derive(Component)]",
      "struct Mover;",
      "",
      "fn startup(mut commands: Commands) {",
      "    commands.spawn(Camera2d);",
      "",
      "    commands.spawn((",
      "        Sprite {",
      "            color: Color::srgb(0.3, 0.7, 0.9),",
      "            custom_size: Some(Vec2::new(100.0, 100.0)),",
      "            ..default()",
      "        },",
      "        Transform::from_xyz(0.0, 0.0, 0.0),",
      "        Mover,",
      "    ));",
      "}",
      "",
      "fn move_square(time: Res<Time>, mut query: Query<&mut Transform, With<Mover>>) {",
      "    for mut transform in &mut query {",
      "        transform.translation.x += 100.0 * time.delta_secs();",
      "    }",
      "}"
    ],
    "description": "A Bevy template with a moving square example"
  },

	"Initialize main.rs for Procon": {
    "prefix": "aci",
    "body": [
      "use proconio::input;",
      "use std::io::{self,BufWriter, Write, stdout};",
      "",
      "fn main() {",
      "    let stdout = stdout();",
      "    let mut out = BufWriter::new(stdout.lock());",
      "    let mut ans = 0;",
      "    input!{",
      "        //n:usize,",
	  "        //a: [i32; n],//入力典型",
      "    }",
      "    //writeln!(out, \"{}\", ans).unwrap();//出力典型",
      "}"
    ],
    "description": "Procon template"
  },

  "Fenwick Tree (Binary Indexed Tree)": {
    "prefix": "fenwick",
    "body": [
      "fn lsb(i: usize) -> usize {",
      "    i & i.wrapping_neg()",
      "}",
      "",
      "struct Fenwick {",
      "    table: Vec<i32>,",
      "}",
      "",
      "impl Fenwick {",
      "    pub fn new() -> Self {",
      "        Self { table: vec![0] }",
      "    }",
      "",
      "    pub fn push(&mut self, mut x: i32) {",
      "        let n = self.table.len();",
      "        let mut d = 1;",
      "        let k = lsb(n);",
      "        while d != k {",
      "            x += self.table[n - d];",
      "            d *= 2;",
      "        }",
      "        self.table.push(x);",
      "    }",
      "",
      "    pub fn prefix_sum(&self, mut i: usize) -> i32 {",
      "        let mut res = 0;",
      "        while i != 0 {",
      "            res += self.table[i];",
      "            i -= lsb(i);",
      "        }",
      "        res",
      "    }",
      "",
      "    pub fn add(&mut self, mut i: usize, x: i32) {",
      "        i += 1;",
      "        while i < self.table.len() {",
      "            self.table[i] += x;",
      "            i += lsb(i);",
      "        }",
      "    }",
      "",
      "    pub fn build(src: &[i32]) -> Self {",
      "        let mut table = vec![0; src.len() + 1];",
      "        for i in 1..table.len() {",
      "            let x = src[i - 1];",
      "            table[i] += x;",
      "            let j = i + lsb(i);",
      "            if j < table.len() {",
      "                table[j] += table[i];",
      "            }",
      "        }",
      "        Self { table }",
      "    }",
      "}"
    ],
    "description": "Binary Indexed Tree (Fenwick Tree) implementation in Rust"
  },
  "Fast math mod utils (mathmod)": {
    "prefix": "mathmod",
    "body": [
      "const MOD: usize = 1_000_000_007;",
      "",
      "fn mod_pow(mut base: usize, mut exp: usize, m: usize) -> usize {",
      "    let mut result = 1;",
      "    while exp > 0 {",
      "        if exp % 2 == 1 {",
      "            result = result * base % m;",
      "        }",
      "        base = base * base % m;",
      "        exp /= 2;",
      "    }",
      "    result",
      "}",
      "",
      "fn modinv(a: usize, m: usize) -> usize {",
      "    mod_pow(a, m - 2, m)",
      "}",
      "",
      "fn prepare_factorials(size: usize, m: usize) -> (Vec<usize>, Vec<usize>) {",
      "    let mut fact = vec![1; size + 1];",
      "    let mut inv_fact = vec![1; size + 1];",
      "    for i in 1..=size {",
      "        fact[i] = fact[i - 1] * i % m;",
      "    }",
      "    inv_fact[size] = modinv(fact[size], m);",
      "    for i in (1..size).rev() {",
      "        inv_fact[i] = inv_fact[i + 1] * (i + 1) % m;",
      "    }",
      "    (fact, inv_fact)",
      "}",
      "",
      "fn comb(n: usize, r: usize, fact: &Vec<usize>, inv_fact: &Vec<usize>) -> usize {",
      "    if r > n { return 0; }",
      "    fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD",
      "}",
      "",
      "fn perm(n: usize, r: usize, fact: &Vec<usize>, inv_fact: &Vec<usize>) -> usize {",
      "    if r > n { return 0; }",
      "    fact[n] * inv_fact[n - r] % MOD",
      "}",
      "",
      "// 使い方例",
      "// let (fact, inv_fact) = prepare_factorials(100000, MOD);",
      "// println!(\"{}\", comb(10, 3, &fact, &inv_fact));",
      "// println!(\"{}\", perm(10, 3, &fact, &inv_fact));"
    ],
    "description": "高速なmod付き階乗/組み合わせ/順列関数 with mathmod"
  },

}